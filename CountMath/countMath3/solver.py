def симпсона(функция, a, b, точность, k):
    n = 4
    интегральная_сумма = -5
    интегральная_сумма_предыдущая = точность * 2
    while abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1)) > точность:
        интегральная_сумма_предыдущая = интегральная_сумма
        интегральная_сумма = 0
        h = (abs(a - b)) / n
        for i in range(n):
            интегральная_сумма += (((a + h * (i + 1)) - (a + h * i)) / 6) * (функция(a + h * i) + 4 * функция(((a + h * i) + (a + h * (i + 1))) / 2) + функция(a + h * (i + 1)))
        n *= 2

    return интегральная_сумма, n / 2, abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1))


def трапеции(функция, a, b, точность, k):
    n = 4
    интегральная_сумма = -5
    интегральная_сумма_предыдущая = точность * 2
    while abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1)) > точность:
        интегральная_сумма_предыдущая = интегральная_сумма
        интегральная_сумма = 0
        h = (abs(a - b)) / n
        for i in range(n):
            интегральная_сумма += ((функция(a + h * i) + функция(a + h * (i + 1))) / 2) * ((a + h * (i + 1)) - (a + h * i))
        n *= 2

    return интегральная_сумма, n / 2, abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1))


def правые(функция, a, b, точность, k):
    n = 4
    интегральная_сумма = -5
    интегральная_сумма_предыдущая = точность * 2
    while abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1)) > точность:
        интегральная_сумма_предыдущая = интегральная_сумма
        интегральная_сумма = 0
        h = (abs(a - b)) / n
        for i in range(n):
            интегральная_сумма += функция(a + h * (i + 1)) * ((a + h * (i + 1)) - (a + h * i))
        n *= 2

    return интегральная_сумма, n / 2, abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1))


def левые(функция, a, b, точность, k):
    n = 4
    интегральная_сумма = -5
    интегральная_сумма_предыдущая = точность * 2
    while abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1)) > точность:
        интегральная_сумма_предыдущая = интегральная_сумма
        интегральная_сумма = 0
        h = (abs(a - b)) / n
        for i in range(n):
            интегральная_сумма += функция(a + h * i) * ((a + h * (i + 1)) - (a + h * i))
        n *= 2

    return интегральная_сумма, n / 2, abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1))


def средние(функция, a, b, точность, k):
    n = 4
    интегральная_сумма = -5
    интегральная_сумма_предыдущая = точность * 2
    while abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1)) > точность:
        интегральная_сумма_предыдущая = интегральная_сумма
        интегральная_сумма = 0
        h = (abs(a - b)) / n
        for i in range(n):
            интегральная_сумма += функция(((a + h * i) + (a + h * (i + 1))) / 2) * ((a + h * (i + 1)) - (a + h * i))
        n *= 2

    return интегральная_сумма, n / 2, abs((интегральная_сумма_предыдущая - интегральная_сумма) / (2 ** k - 1))


def разрыв_первого_порядка(функция, метод, a, b, точка_разрыва, точность):
    if a <= точка_разрыва <= b:
        if a == точка_разрыва:
            return метод(функция, a + точность, b, точность, 4)[0]
        elif b == точка_разрыва:
            return метод(функция, a, b - точность, точность, 4)[0]
        else:
            return метод(функция, a, точка_разрыва - точность, точность, 4)[0] + \
                   метод(функция, точка_разрыва + точность, b, точность, 4)[0]
    else:
        return метод(функция, a, b, точность, 4)[0]


def разрыв_второго_порядка(функция, метод, a, b, точка_разрыва, точность):
    if a <= точка_разрыва <= b:
        print("Интеграл не существует")
        exit()
    else:
        return метод(функция, a, b, точность, 4)[0]

